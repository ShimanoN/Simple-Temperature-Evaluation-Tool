# 温度評価ツール コード完全解説書

> **"Simple can be harder than complex."**
> 
> このドキュメントは、M5Stack温度評価ツールのコード（`main.cpp`）を、「単なる文字の羅列」ではなく**「生きている仕組み」**として理解するためのガイドです。
> プログラミング言語の文法よりも、**「なぜそう設計されているのか？」**というエンジニアの思考プロセスに焦点を当てています。

---

## 1. 整理整頓の極意

### 📂 バインダー：`struct`（構造体）
GX Works3などでいう**「グローバルラベル」**や**「構造体データ」**に非常に近い概念です。

もし、変数をバラバラに作っていたら、コードのあちこちにデータが散らばって管理不能になります。そこで、**「このプロジェクトの共通データは、全部このバインダー（G）に綴じる！」**と決めるのが `struct` です。

```cpp
struct {
  float  D_RawPV;       // センサ生値
  float  D_FilteredPV;  // フィルタ後の値
  double D_Sum;         // 合計
  long   D_Count;       // 回数
} G; // このバインダーを「G（Global）」と名付ける
```

取り出すときは必ず **`G.`** をつけて呼び出します（例：`G.D_Sum`）。これによって、「あ、これはお弁当箱（G）の中の具材（変数）なんだな」と一目でわかります。

---

## 1. 登場人物（変数と型）

プログラムの世界には、様々なサイズの「箱」が登場します。中に入れるものに合わせて、適切な箱を選ぶのが第一歩です。

### 🌡️ 温度を入れる箱 (`float`, `double`)

温度は `25.5` のように小数点が必要です。

- **`float` (フロート)**: 一般的な小数を入れる箱。
  - 用途: `D_RawPV` (センサから読んだ瞬間の値)
- **`double` (ダブル)**: `float` の2倍の精度と大きさを持つ巨大な箱。
  - 用途: `D_Sum` (積算値)
  - **Why?**: 足し算を1万回繰り返すと、小さな箱(`float`)では桁が溢れたり、誤差が積もって数字が正確でなくなります。だからここだけは、贅沢に巨大な箱を使っています。

### ⏱️ 時間を数える箱 (`unsigned long`)

時間は `0` から始まって、ひたすら増え続けます。マイナスの時間は存在しません。

- **`unsigned long`**: 符号なし（プラスのみ）の巨大な整数。
  - 用途: `now`, `T_IO_Last`
  - **Why?**: マイコンが起動してから何ミリ秒経ったか？という数字は、数日で数十億という数になります。これを受け止められるのはこの型だけです。

---

## 2. 構造（全体のリズム）

このプログラムは、大きく2つの場所に分かれています。

### 🏁 `setup()` : 準備（一度だけ）

電源を入れた瞬間に**1回だけ**実行されます。

- 作業机を並べる（変数の初期化）
- 道具の点検をする（センサ接続チェック）
- 準備完了の合図をだす（画面表示）

### 🔄 `loop()` : ルーティン（永遠に繰り返す）

ここがメインです。電源が切れるまで、何億回も高速で繰り返されます。
しかし、ただ全力で繰り返すとCPUが疲弊し、画面もチラついてしまいます。そこで**「タイマー」**という概念を導入しています。

#### "If Timer" パターン

```cpp
// 「今」が「前回やった時間」より「10ms」以上進んでいたら...
if (now - T_IO_Last >= IO_CYCLE) {
    T_IO_Last = now; // 「やった時間」を更新して
    IO_Task();       // 仕事をする！
}
```

これは**「メトロノーム」**です。

- 10ms (0.01秒) ごとに `IO_Task`（センサ確認）
- 50ms (0.05秒) ごとに `Logic_Task`（計算）
- 200ms (0.2秒) ごとに `UI_Task`（画面更新）

こうすることで、それぞれの仕事が最適なリズムで動き続けます。

---

## 3. 状態遷移（State Machine）

多機能な道具を作るとき、一番怖いのは「今なにをしてるんだっけ？」と混乱することです。
これを防ぐために、**「今は〇〇モード！」**と、状態を明確に定義します。これを**ステートマシン**と呼びます。

### 🚦 信号機のような仕組み

```cpp
switch (G.M_CurrentState) {
    case STATE_IDLE:   // 待機中
        // 何もしない、またはリセット処理
        break;

    case STATE_RUN:    // 計測中
        // ひたすら足し算をする
        break;

    case STATE_RESULT: // 結果表示
        // 平均値を計算して出す
        break;
}
```

- **メリット**: 「計測中にはリセットしたくない」「結果表示中は足し算したくない」といった制御が、`case` の中に書くだけで自然と実現できます。バグを防ぐための最も強力なパターンです。

### 🕹️ セレクタスイッチを「回す」瞬間 (`Logic_Task`)

`enum` で定義したラベル（待機・計測・結果）を、実際にカチカチと切り替えているのが `Logic_Task` のスイッチ文です。

```cpp
if (G.M_CurrentState == STATE_IDLE) {
    // 待機中なら「計測開始」へスイッチを回す準備
}
```

PLCでいうところの **「工程歩進（ステップ制御）」** です。
「ボタンが押された」という信号をきっかけに、今の状態（工程）を確認し、次の状態へスイッチをガチャンと回す。この「今どこにいるか」の管理を徹底することで、「待機中なのに勝手に計算が始まる」といった意図しない動作を防いでいます。

---

## 4. データ処理のマジック

温度計の信頼性を支える、2つの計算ロジックについて解説します。

### 💧 クッションの役割（一次遅れフィルタ）

センサから来る生の数字（Raw Data）は、実はかなり暴れています。電気的なノイズが乗ってパラパラ動くのを滑らかにするのがこの数式です。

```cpp
// フィルタ係数を定数化（保守性向上）
constexpr float FILTER_ALPHA = 0.1f;

// 1次遅れフィルタ: y[n] = y[n-1] * (1-α) + x[n] * α
Filtered = (Filtered * (1.0f - FILTER_ALPHA)) + (Raw * FILTER_ALPHA);
```

- **「今までの実績」を9割**信じる。
- **「新入り（生データ）」は1割**だけ聞き入れる。

こうすると、突発的な誤差が来ても数値がジワッとしか動きません。人間が見ていて「安心できる」滑らかな数字になります。これを **「ローパスフィルタ」** と呼びます。

**Why 定数化？**: マジックナンバー（`0.9`, `0.1`）をコード中に直接書くと、後から「フィルタを強くしたい」と思ったときに、コードのあちこちを探し回る羽目になります。定数 `FILTER_ALPHA` として一箇所で管理することで、チューニングが容易になります。

### 🧮 貯金箱の数え上げ（平均値計算）

「RUN（計測中）」の間だけ、以下の2つを高速で行っています。

1. **`D_Sum`**: お金（温度）を貯金箱にどんどん放り込む。
2. **`D_Count`**: 放り込んだ回数を正の字でカウントする。

最後に「RESULT」に切り替わったとき、**「貯金額 ÷ 枚数 = 1枚あたりの平均」** という算数を行い、平均温度を算出します。

```cpp
if (G.D_Count > 0) {
    G.D_Average = G.D_Sum / G.D_Count;
} else {
    // サンプル数0の場合は現在値を使用（ゼロ除算保護）
    G.D_Average = G.D_FilteredPV;
}
```

非常に原始的ですが、数万回のサンプルを計算するため、非常に精度の高い平均値が得られます。

**Why ゼロ除算保護？**: ボタンを押してすぐに終了した場合、`D_Count = 0` になり、割り算でエラーが発生します。このような「エッジケース（想定外の使い方）」でも安全に動作させるため、`else` 節で現在値を代入しています。これは現場での頑丈さ（ロバスト性）の基本です。

---

## 5. 無効値ガード（NaN Guard）

現場では、ケーブルの接触不良などで `NaN` (Not a Number = 非数) 信号が来ることがあります。

```cpp
if (!isnan(G.D_RawPV)) {
    // NaNじゃないときだけ、計算機を回す
}
```

これは **「腐ったミカンを箱に入れない」** ための防衛線です。不具合データを無視して前回の値を使い続けることで、現場での頑丈さ（ロバスト性）を確保しています。

---

## まとめ：エンジニアの視点

このコード `main.cpp` は、以下の3つの信頼性を追求して作られています。

1. **リズム**: タイマーでCPUリソースを適切に配分する。
2. **規律**: ステートマシンで今の役割を明確にする。
3. **正確性**: フィルタとNaNガードでエラーを排除する。

これは、あらゆる工業製品の制御に通ずる基本原則です。

---

## 6. コード品質向上のための改善

初期実装から、以下の改善を実施しました。これらは「動くコード」を「保守できるコード」へと進化させるための実践例です。

### 🔧 定数の型安全化 (`constexpr`)

**Before:**
```cpp
#define IO_CYCLE 10
```

**After:**
```cpp
constexpr unsigned long IO_CYCLE_MS = 10UL;
```

**Why?**: `#define` はコンパイラによる型チェックが効かず、デバッグ時に問題を見つけにくくなります。`constexpr` を使うことで、型安全性を確保し、意図しない型変換を防ぎます。また、`_MS` サフィックスで単位を明示することで、可読性も向上します。

### 🎯 マジックナンバーの排除

**Before:**
```cpp
G.D_FilteredPV = (G.D_FilteredPV * 0.9) + (G.D_RawPV * 0.1);
```

**After:**
```cpp
constexpr float FILTER_ALPHA = 0.1f;
G.D_FilteredPV = (G.D_FilteredPV * (1.0f - FILTER_ALPHA)) + (G.D_RawPV * FILTER_ALPHA);
```

**Why?**: `0.9` や `0.1` といった数字が何を意味するのか、コードを読むだけでは分かりません。定数化することで、「フィルタ係数」という意味を明示し、調整時の変更箇所を一箇所に集約できます。

### 🛡️ 初期化の構造化と潜在バグ修正

**Before:**
```cpp
void setup() {
    // ... 初期化処理が setup() 内に直接記述
    G.D_FilteredPV = 0.0;
    // D_Average の初期化が漏れている！
}
```

**After:**
```cpp
void initGlobalData() {
    G.M_CurrentState  = STATE_IDLE;
    G.D_FilteredPV    = 0.0;
    G.D_Sum           = 0.0;
    G.D_Count         = 0;
    G.D_Average       = 0.0;  // 初期化漏れを修正
    G.M_BtnA_Pressed  = false;
    G.M_BtnA_Prev     = false;
}

void setup() {
    // ...
    initGlobalData();
    // ...
    G.D_FilteredPV = testTemp;  // 実測値で初期化
}
```

**Why?**: 
- 初期化処理を関数化することで、再利用性と可読性が向上
- `D_Average` の初期化漏れを発見・修正（計測せずに結果表示すると不定値が表示される潜在バグ）
- フィルタ初期値を実測値で初期化することで、起動直後の収束時間を短縮

### 🛡️ ゼロ除算保護

**Before:**
```cpp
if (G.D_Count > 0) {
    G.D_Average = G.D_Sum / G.D_Count;
}
// else 節がない → D_Average は未定義のまま
```

**After:**
```cpp
if (G.D_Count > 0) {
    G.D_Average = G.D_Sum / G.D_Count;
} else {
    G.D_Average = G.D_FilteredPV;  // サンプル数0でも安全
}
```

**Why?**: ユーザーがボタンを押してすぐに終了した場合、サンプル数が0になります。この「エッジケース」でも安全に動作させることが、現場で使われるツールの条件です。

### 📝 PLC対応表の明示

**Global.h に追加:**
```cpp
// PLC対応表:
//   D_系 → データレジスタ (PLC の D デバイス相当)
//   M_系 → 内部リレー (PLC の M デバイス相当)
```

**Why?**: PLCエンジニアが読んだときに、「あ、これはDデバイスの考え方だな」と即座に理解できるようにするためのドキュメント。コードは「動くこと」だけでなく、「読まれること」も重要です。

---

## 学んだこと

- **「動く」と「良い」は別物**: 初期実装は動作していましたが、潜在バグや保守性の問題を抱えていました。
- **エッジケースを想定する**: 「普通の使い方」だけでなく、「想定外の使い方」でも壊れないコードが現場では求められます。
- **定数化は保守性の基本**: マジックナンバーを排除し、意味のある名前を付けることで、将来の自分や他のエンジニアが理解しやすくなります。

