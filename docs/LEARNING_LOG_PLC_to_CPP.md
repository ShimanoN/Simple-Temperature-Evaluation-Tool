# C++ for PLC Engineers: The "Translation" Guide
**〜 M5Stack温度評価ツール開発から学ぶ、制御屋のためのC++入門 〜**

本ドキュメントは、PLC（三菱 GX Works3等）の経験を持つエンジニアが、その既存知識を武器にしてC++（Arduino Framework）を理解するための「翻訳辞書」です。
単なる用語の対比だけでなく、「なぜそうするのか（思想）」の共通点に重点を置いています。

---

## 1. データ構造と整理整頓 (Data Structure)

プログラムが散らからないようにするための「箱」と「棚」の技術です。

### 📁 バインダー：`struct`
**PLC概念**: **構造体データ (Structure) / グローバルラベル**

変数をバラバラに管理せず、関連するものを「一つのカタマリ」として扱います。

- **C++**:
  ```cpp
  struct GlobalData {
      float Temp;
      bool  Signal;
  } G; // Gという名前の実体を作る
  // 使うとき: G.Temp, G.Signal
  ```
- **PLC**:
  ユーザー定義構造体 `stMachineData` を作り、グローバルラベル `G` に割り当てる。
  ラダー内では `G.Temp` のようにドットでアクセスするのと同じ。

### 🎛️ セレクタスイッチ：`enum`
**PLC概念**: **状態定義定数 / デバイスコメントによる定義**

「0=停止, 1=運転, 2=異常」のように、数字に「意味のある名前（ラベル）」を貼り付けます。

- **C++**:
  ```cpp
  enum State { IDLE, RUN, ALARM };
  // 中身は 0, 1, 2 だが、コード上は名前で扱える
  ```
- **PLC**:
  内部デバイス `D100` のコメントに `0:停止 1:運転` と書いたり、グローバル定数 `c_RUN = 1` を定義する感覚。マジックナンバー（謎の数字）を排除できる。

### 📡 共有宣言：`extern`
**PLC概念**: **外部参照ラベル (Global Label External)**

ファイル（プログラム部品）を分けたときに、「実体はあっち（別ファイル）にあるデバイスを使うよ」という宣言。

- **C++**: `extern GlobalData G;` （Gはよそにあるぞ！）
- **PLC**: プログラムブロック間でローカルラベルではなくグローバルラベルを参照する設定。これがないと「二重定義（同じ名前のデバイスが2つある）」エラーになる。

---

## 2. 時間と周期の管理 (System & Timer)

マイコンにはPLCのような「スキャンタイム」が自動ではないため、自分でリズムを作ります。

### ⏱️ システムクロック：`millis()`
**PLC概念**: **内部クロック / システムタイマー現在値**

電源投入時から、1ミリ秒ごとにカウントアップし続ける「止まらないストップウォッチ」。
約50日でオーバーフロー（0に戻る）するが、引き算で使う限り問題ない。

### 🔄 定周期実行：`now - Last >= Cycle`
**PLC概念**: **定周期タイマー接点 + 自己保持解除**

C++には「10msタイマーコイル」がないため、この計算式で代用します。

```cpp
// 現在値(now) - 前回実施値(Last) が 設定値(10ms) を超えたら？
if (now - T_Last >= 10) {
    T_Last = now; // 前回実施値を更新（タイマーリセット）
    DoProcess();  // 処理実行
}
```
**思想**: これは「一定量溜まったらバルブを開く」という**バケツリレー**の発想です。
PLCの定周期割り込みタスクと同じ挙動を、メインループ内で実現しています。

---

## 3. ロジック制御 (Logic Control)

### 🚦 状態遷移：`switch-case`
**PLC概念**: **工程歩進制御 (ステップラダー / SFC)**

「今どの工程にいるか？」によって、やるべき処理を分岐させます。

- **C++**:
  ```cpp
  switch (CurrentState) {
      case IDLE: ... break; // 工程10
      case RUN:  ... break; // 工程20
  }
  ```
- **PLC**:
  `[MOV K10 D_Step]` で工程をセットし、`[= D_Step K10]` 接点で回路を駆動するのと同じ。
  インターロック（混線防止）の基本形。

### ⚡ 立ち上がり検出：`if (now && !prev)`
**PLC概念**: **PLP (Pulse P) / LDP (Load Pulse)**

ボタンが「押され続けている」のと「押された瞬間」を区別します。

- **C++**:
  ```cpp
  if (btnNow == true && btnPrev == false) {
      // 0→1 になった瞬間だけここを通る
  }
  btnPrev = btnNow; // 次回のために履歴を保存
  ```
- **PLC**:
  ラダーの `↑` 接点や `PLS` 命令そのもの。マイコンでは1スキャン前の状態を自分で変数(`Prev`)に保存して比較する必要があります。

---

## 4. アーキテクチャ (Design Pattern)

### 🏭 3層構造 (IO / Logic / UI)
**PLC概念**: **入出力リフレッシュ + プログラム分割**

プログラムをごちゃ混ぜにせず、役割で分けました。

1.  **IO_Task (10ms)**: 入力リフレッシュ。チャタリング除去やスケーリング（フィルタ）を行い、綺麗なデータを渡す。
2.  **Logic_Task (50ms)**: メイン回路。状態遷移や積算処理を行う。
3.  **UI_Task (200ms)**: HMI表示。重い処理なので、頻度を落として実行する。

**Why?**: 表示器の更新（UI）が遅れても、制御（Logic）やセンサ読み取り（IO）は止めてはいけないからです。優先順位の設計です。

### 📑 宣言と定義の分離 (.h / .cpp)
**PLC概念**: **変数定義テーブル と ラダー図 の分離**

- **ヘッダ(.h)**: 「どんなFBや変数が使えるか」のリスト（メニュー表）。
- **ソース(.cpp)**: 具体的な中身（調理場）。

`main.cpp` は、メニュー表を見て注文（呼び出し）をするだけで、調理手順（中身）を知る必要がないため、コードがスッキリします。

---

## 5. まとめ

今回の学習で、C++特有に見える構文も、実は**「制御屋が普段ラダーでやっていること」を文字で書いているだけ**だと判明しました。

- アルファベットの羅列にビビらない。
- 「これはラダーで言うとどの回路だ？」と脳内変換する。

この視点さえあれば、M5Stackに限らず、どんなマイコン開発でもPLCエンジニアの資産がそのまま活かせます。

---

## 6. コード品質向上のPLC的解釈

初期実装から実施した改善を、PLC開発の観点から解説します。

### 🔧 定数の型安全化：`#define` vs `constexpr`

**PLC概念**: **グローバル定数 (Constant) の定義方法**

- **`#define` (旧式)**:
  ```cpp
  #define IO_CYCLE 10
  ```
  - PLCで言うと、「コメントに書いてあるだけの定数」
  - コンパイラが型チェックしない（数値なのか文字列なのか不明）
  - デバッグ時にエラー箇所が分かりにくい

- **`constexpr` (推奨)**:
  ```cpp
  constexpr unsigned long IO_CYCLE_MS = 10UL;
  ```
  - PLCで言うと、「グローバル定数として正式に登録された値」
  - 型が明確（unsigned long = 符号なし32bit整数）
  - コンパイラが型チェックしてくれる（安全）
  - `_MS` サフィックスで単位を明示（可読性向上）

**Why?**: PLCでも「D100に10を入れる」より「c_CYCLE_TIME = 10」と定数化した方が、後から見たときに意味が分かりやすい。C++でも同じ思想です。

### 🎯 マジックナンバーの排除

**PLC概念**: **定数化によるプログラムの可読性向上**

**Before:**
```cpp
G.D_FilteredPV = (G.D_FilteredPV * 0.9) + (G.D_RawPV * 0.1);
```

**After:**
```cpp
constexpr float FILTER_ALPHA = 0.1f;
G.D_FilteredPV = (G.D_FilteredPV * (1.0f - FILTER_ALPHA)) + (G.D_RawPV * FILTER_ALPHA);
```

**PLC的解釈**: ラダーで `[MOV K90 D_FilterGain]` と書くより、`[MOV c_FILTER_GAIN D_FilterGain]` と書いた方が、「90って何？」と悩まずに済む。定数名が自己説明的になる。

### 🛡️ 初期化の構造化

**PLC概念**: **初期化処理のサブルーチン化**

**Before:**
```cpp
void setup() {
    G.D_FilteredPV = 0.0;
    G.D_Sum = 0.0;
    // ... 初期化処理が setup() 内に直接記述
}
```

**After:**
```cpp
void initGlobalData() {
    G.M_CurrentState  = STATE_IDLE;
    G.D_FilteredPV    = 0.0;
    G.D_Sum           = 0.0;
    G.D_Count         = 0;
    G.D_Average       = 0.0;  // 初期化漏れを修正
    // ...
}

void setup() {
    initGlobalData();  // サブルーチン呼び出し
}
```

**PLC的解釈**: 初期化処理を「FB_INIT」のような専用サブルーチンにまとめることで、再利用性が向上。また、初期化漏れ（`D_Average`）を発見・修正できた。これは「デバイス初期値設定漏れ」と同じ潜在バグ。

### 🛡️ ゼロ除算保護

**PLC概念**: **異常値処理 / インターロック**

**Before:**
```cpp
if (G.D_Count > 0) {
    G.D_Average = G.D_Sum / G.D_Count;
}
// else 節がない → 不定値のまま
```

**After:**
```cpp
if (G.D_Count > 0) {
    G.D_Average = G.D_Sum / G.D_Count;
} else {
    G.D_Average = G.D_FilteredPV;  // フェールセーフ
}
```

**PLC的解釈**: ラダーで「カウンタ値が0のときは除算命令を実行しない」というインターロックを入れるのと同じ。エッジケース（想定外の操作）でも安全に動作させる「フェールセーフ設計」の基本。

### 📝 PLC対応表の明示

**Global.h に追加:**
```cpp
// PLC対応表:
//   D_系 → データレジスタ (PLC の D デバイス相当)
//   M_系 → 内部リレー (PLC の M デバイス相当)
```

**PLC的解釈**: プログラムの冒頭に「デバイス使用一覧表」や「命名規則」を書くのと同じ。他のエンジニアが読んだときに、「あ、これはDデバイスの考え方だな」と即座に理解できる。

---

## 7. 学んだこと（追加）

- **「動く」と「良い」は別物**: 初期実装は動作していたが、潜在バグ（初期化漏れ、ゼロ除算）や保守性の問題を抱えていた。PLCでも同じ。「とりあえず動く」ラダーと「保守できる」ラダーは違う。
- **エッジケースを想定する**: 「普通の使い方」だけでなく、「想定外の使い方」でも壊れないコードが現場では求められる。これはPLCの「異常時動作確認」と同じ思想。
- **定数化は保守性の基本**: マジックナンバーを排除し、意味のある名前を付けることで、将来の自分や他のエンジニアが理解しやすくなる。PLCのグローバル定数と同じ。
- **型安全性の重要性**: C++では`constexpr`を使うことで、PLCの「デバイス型指定」と同等の安全性を確保できる。`#define`は「コメント」、`constexpr`は「正式な定数登録」と考えると分かりやすい。

