# C++ for PLC Engineers: The "Translation" Guide
**〜 M5Stack温度評価ツール開発から学ぶ、制御屋のためのC++入門 〜**

本ドキュメントは、PLC（三菱 GX Works3等）の経験を持つエンジニアが、その既存知識を武器にしてC++（Arduino Framework）を理解するための「翻訳辞書」です。
単なる用語の対比だけでなく、「なぜそうするのか（思想）」の共通点に重点を置いています。

---

## 1. データ構造と整理整頓 (Data Structure)

プログラムが散らからないようにするための「箱」と「棚」の技術です。

### 📁 バインダー：`struct`
**PLC概念**: **構造体データ (Structure) / グローバルラベル**

変数をバラバラに管理せず、関連するものを「一つのカタマリ」として扱います。

- **C++**:
  ```cpp
  struct GlobalData {
      float Temp;
      bool  Signal;
  } G; // Gという名前の実体を作る
  // 使うとき: G.Temp, G.Signal
  ```
- **PLC**:
  ユーザー定義構造体 `stMachineData` を作り、グローバルラベル `G` に割り当てる。
  ラダー内では `G.Temp` のようにドットでアクセスするのと同じ。

### 🎛️ セレクタスイッチ：`enum`
**PLC概念**: **状態定義定数 / デバイスコメントによる定義**

「0=停止, 1=運転, 2=異常」のように、数字に「意味のある名前（ラベル）」を貼り付けます。

- **C++**:
  ```cpp
  enum State { IDLE, RUN, ALARM };
  // 中身は 0, 1, 2 だが、コード上は名前で扱える
  ```
- **PLC**:
  内部デバイス `D100` のコメントに `0:停止 1:運転` と書いたり、グローバル定数 `c_RUN = 1` を定義する感覚。マジックナンバー（謎の数字）を排除できる。

### 📡 共有宣言：`extern`
**PLC概念**: **外部参照ラベル (Global Label External)**

ファイル（プログラム部品）を分けたときに、「実体はあっち（別ファイル）にあるデバイスを使うよ」という宣言。

- **C++**: `extern GlobalData G;` （Gはよそにあるぞ！）
- **PLC**: プログラムブロック間でローカルラベルではなくグローバルラベルを参照する設定。これがないと「二重定義（同じ名前のデバイスが2つある）」エラーになる。

---

## 2. 時間と周期の管理 (System & Timer)

マイコンにはPLCのような「スキャンタイム」が自動ではないため、自分でリズムを作ります。

### ⏱️ システムクロック：`millis()`
**PLC概念**: **内部クロック / システムタイマー現在値**

電源投入時から、1ミリ秒ごとにカウントアップし続ける「止まらないストップウォッチ」。
約50日でオーバーフロー（0に戻る）するが、引き算で使う限り問題ない。

### 🔄 定周期実行：`now - Last >= Cycle`
**PLC概念**: **定周期タイマー接点 + 自己保持解除**

C++には「10msタイマーコイル」がないため、この計算式で代用します。

```cpp
// 現在値(now) - 前回実施値(Last) が 設定値(10ms) を超えたら？
if (now - T_Last >= 10) {
    T_Last = now; // 前回実施値を更新（タイマーリセット）
    DoProcess();  // 処理実行
}
```
**思想**: これは「一定量溜まったらバルブを開く」という**バケツリレー**の発想です。
PLCの定周期割り込みタスクと同じ挙動を、メインループ内で実現しています。

---

## 3. ロジック制御 (Logic Control)

### 🚦 状態遷移：`switch-case`
**PLC概念**: **工程歩進制御 (ステップラダー / SFC)**

「今どの工程にいるか？」によって、やるべき処理を分岐させます。

- **C++**:
  ```cpp
  switch (CurrentState) {
      case IDLE: ... break; // 工程10
      case RUN:  ... break; // 工程20
  }
  ```
- **PLC**:
  `[MOV K10 D_Step]` で工程をセットし、`[= D_Step K10]` 接点で回路を駆動するのと同じ。
  インターロック（混線防止）の基本形。

### ⚡ 立ち上がり検出：`if (now && !prev)`
**PLC概念**: **PLP (Pulse P) / LDP (Load Pulse)**

ボタンが「押され続けている」のと「押された瞬間」を区別します。

- **C++**:
  ```cpp
  if (btnNow == true && btnPrev == false) {
      // 0→1 になった瞬間だけここを通る
  }
  btnPrev = btnNow; // 次回のために履歴を保存
  ```
- **PLC**:
  ラダーの `↑` 接点や `PLS` 命令そのもの。マイコンでは1スキャン前の状態を自分で変数(`Prev`)に保存して比較する必要があります。

---

## 4. アーキテクチャ (Design Pattern)

### 🏭 3層構造 (IO / Logic / UI)
**PLC概念**: **入出力リフレッシュ + プログラム分割**

プログラムをごちゃ混ぜにせず、役割で分けました。

1.  **IO_Task (10ms)**: 入力リフレッシュ。チャタリング除去やスケーリング（フィルタ）を行い、綺麗なデータを渡す。
2.  **Logic_Task (50ms)**: メイン回路。状態遷移や積算処理を行う。
3.  **UI_Task (200ms)**: HMI表示。重い処理なので、頻度を落として実行する。

**Why?**: 表示器の更新（UI）が遅れても、制御（Logic）やセンサ読み取り（IO）は止めてはいけないからです。優先順位の設計です。

### 📑 宣言と定義の分離 (.h / .cpp)
**PLC概念**: **変数定義テーブル と ラダー図 の分離**

- **ヘッダ(.h)**: 「どんなFBや変数が使えるか」のリスト（メニュー表）。
- **ソース(.cpp)**: 具体的な中身（調理場）。

`main.cpp` は、メニュー表を見て注文（呼び出し）をするだけで、調理手順（中身）を知る必要がないため、コードがスッキリします。

---

## 5. まとめ

今回の学習で、C++特有に見える構文も、実は**「制御屋が普段ラダーでやっていること」を文字で書いているだけ**だと判明しました。

- アルファベットの羅列にビビらない。
- 「これはラダーで言うとどの回路だ？」と脳内変換する。

この視点さえあれば、M5Stackに限らず、どんなマイコン開発でもPLCエンジニアの資産がそのまま活かせます。
