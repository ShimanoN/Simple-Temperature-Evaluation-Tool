# main.cpp のコード解説

## 「設計の意図と背景」を理解するためのウォークスルー

対象読者: M5Stack開発に参加する新規メンバー  
前提: C/C++ の基本構文は理解済み  
参照コード: `src/main.cpp`

---

## 1. なぜ loop() はこう書いているのか

### タイマーベースのタスク分離

まず、このコードの「骨格」の話です。`loop()` の中身を見てください。

```cpp
void loop() {
  unsigned long now = millis();

  if (now - T_IO_Last >= IO_CYCLE) {
    T_IO_Last = now;
    IO_Task();
  }
  if (now - T_Logic_Last >= LOGIC_CYCLE) {
    T_Logic_Last = now;
    Logic_Task();
  }
  if (now - T_UI_Last >= UI_CYCLE) {
    T_UI_Last = now;
    UI_Task();
  }
}
```

やっていることは単純で、「それぞれのタスクは自分のタイマーが切れたときだけ実行する」という仕組みです。

では、なぜこんなことをするのか。「だったら各タスクの中に `delay()` を入れて順番に実行すればいいのでは」と思うかもしれません。それを書いてみると以下のようになります。

```cpp
// ❌ delay() だけで書いた場合（実装しないでください）
void loop() {
  IO_Task();
  delay(10);      // 10ms待つ
  Logic_Task();
  delay(50);      // 50ms待つ
  UI_Task();
  delay(200);     // 200ms待つ
}
```

これだと 1回のループに合計 **260ms以上** かかるため、以下のような問題が起きます。

**センサの読み込みが遅くなる。** IO_Task は10ms刻みで動く必要がありますが、UI_Task の200ms待機の間はセンサを読んでいません。温度が急に変わった場合に検知が遅くなります。

**ボタン操作がもっさりになる。** ボタン押下の検出も IO_Task 内です。同じ理由で、ボタンを押した瞬間に反応するのではなく、最悪で260ms近くのラグが発生します。実際に使うと「押してるのに何も変わらない」と感じます。

**各タスクの周期が保証できなくなる。** delay() は「少なくとも○ms待つ」という動作です。タスク自身の実行時間も加わると、実際の周期がデザインしたものより長くなります。

タイマーベースの方法では、`loop()` は「全タスクの実行条件をチェックする」だけに徹しているため、各タスクは**互いに妨げずに独立した周期で動く**ことができます。

```
実際の動作イメージ（1ms単位で見ると）

IO_Task は 10ms ごとに実行 ──── センサ読込やボタン検出は常に高頻度
Logic_Task は 50ms ごとに実行 ── 演算は必要なタイミングで
UI_Task は 200ms ごとに実行 ─── 画面更新は無理せず
```

この設計のことを「**非プリエンプティブ（cooperatively scheduled）タスク管理**」と呼んでいます。Arduino や ESP32 のような単一スレッド環境では、この手法がタスク分離の標準的なアプローチです。

---

## 2. なぜ状態遷移（ステートマシン）を使うのか

### switch-case による状態管理の正攻法

Logic_Task の中のこの部分が「状態遷移」です。

```cpp
switch (G.M_CurrentState) {
  case STATE_IDLE:
    // ここを通るのは「IDLE中にボタンが押された」ときのみ
    G.D_Sum          = 0.0;
    G.D_Count        = 0;
    G.M_CurrentState = STATE_RUN;
    break;

  case STATE_RUN:
    // ここを通るのは「RUN中にボタンが押された」ときのみ
    if (G.D_Count > 0) {
      G.D_Average = G.D_Sum / G.D_Count;
    }
    G.M_CurrentState = STATE_RESULT;
    break;

  case STATE_RESULT:
    // ここを通るのは「RESULT中にボタンが押された」ときのみ
    G.M_CurrentState = STATE_IDLE;
    break;
}
```

これを if-else で書き換えたとすると、以下のようなコードになります。

```cpp
// ❌ if-else で書いた場合のイメージ
if (G.M_BtnA_Pressed && !G.M_Running && !G.M_ResultShowing) {
  // IDLE → RUN へ
  G.M_Running = true;
  ...
} else if (G.M_BtnA_Pressed && G.M_Running && !G.M_ResultShowing) {
  // RUN → RESULT へ
  G.M_Running = false;
  G.M_ResultShowing = true;
  ...
} else if (G.M_BtnA_Pressed && !G.M_Running && G.M_ResultShowing) {
  // RESULT → IDLE へ
  G.M_ResultShowing = false;
  ...
}
```

状態が3つの段階でも条件分岐がこれだけ複雑になります。Phase 2で状態や機能が増えると、「今どの組み合わせにいるか」の条件が組み合わせ爆発で把握不能になります。

switch-case のメリットは明確です。**「今の状態」と「次にどうなるか」が1つのケースに対応一対で書かれている**ため、ある状態での動作を変えたときに、他の状態への影響が出ない。つまりバグを混ぜにくい構造です。

さらに「状態遷移図」との対応が直感的になります。以下の図と switch-case のケース順が1:1に対応しているのを確認してください。

```
[IDLE] ──BtnA──> [RUN] ──BtnA──> [RESULT] ──BtnA──> [IDLE]
  case IDLE:       case RUN:        case RESULT:
  → STATE_RUN     → STATE_RESULT   → STATE_IDLE
```

計測器の開発では、状態の数は今後も増える可能性があります（Phase 2で「エラー状態」や「キャリブレーション状態」が追加される、といった例が典型的です）。その際にも、switch-case は「新しいケースを追加するだけで良い」という拡張しやすい構造を維持できます。

---

## 3. 一次遅れフィルタの数学的背景

### (Old × 0.9) + (New × 0.1) が実現していること

IO_Task にある以下の式です。

```cpp
G.D_FilteredPV = (G.D_FilteredPV * 0.9) + (G.D_RawPV * 0.1);
```

この式の物理的イメージは「**熱の慣性**」です。

温度センサが実際に計測しているものは、熱電対の先端の温度です。しかし実際には、センサが特定の温度環境に置かれた直後に「正確な値」が出るわけではありません。センサ自身に質量があるため、熱が伝わるのに時間がかかります。つまり現実の温度センサは「急な変化には遅延して反応する」という動作をします。

この式が実現していることは、まさにこれと同じです。

```
新しい値が突然変わっても、出力値はゆっくりそこに近づく
```

具体的に数値で見てみましょう。室温 25.0℃ を計測していて、突然センサ生値が 30.0℃ になった場合の動き：

```
時刻   生値(RawPV)   フィルタ後(FilteredPV)   計算過程
───────────────────────────────────────────────────────────
t=0    25.0          25.00                    (初期値)
t=10ms 30.0          25.50                    25.0×0.9 + 30.0×0.1
t=20ms 30.0          25.95                    25.5×0.9 + 30.0×0.1
t=30ms 30.0          26.36                    25.95×0.9 + 30.0×0.1
...
t=~100ms 30.0        ≈28.0                    まだ30.0には到達していない
...
t=~250ms 30.0        ≈29.7                     やっと30.0に近づく
```

つまり、5℃の急変に対して約250ms程度かけて徐々に収束します。

この係数（0.9と0.1）をどう選ぶかが調整のポイントです。

```
係数の組み合わせと動作の傾向

0.9 / 0.1 (デフォルト)  → ノイズと追従のバランス。ノイズが少なくて変化も見える
0.95 / 0.05             → ノイズ除去が強い。急変への追従が遅くなる
0.8 / 0.2               → 急変への追従が速い。ノイズが残りやすくなる
```

現場で「温度表示がゲルゲルと揺れる」と感じたら、0.95/0.05に strengthening する。「温度が変わっているのに表示が遅い」と感じたら、0.8/0.2に緩める。この調整は `detailed_spec_sw.md` のカスタマイズ節でも説明されています。

---

## 4. 不具合が起きたときの「当たりつけ」ガイド

現場で起きがちな不具合と、コード上のどこに問題があるかの対応です。

### 「ボタンの反応が悪い」

```cpp
// 確認箇所: IO_Task のボタン読込
bool btnNow = M5.BtnA.isPressed();
if (btnNow && !G.M_BtnA_Prev) {   // ← エッジ検出ここ
  G.M_BtnA_Pressed = true;
}
G.M_BtnA_Prev = btnNow;
```

現在の実装はエッジ検出（前回と今回の差分で判定）のみです。物理ボタンの押下には「チャタリング」と呼ばれるバウンス（電気的な揺れで、数ms〜数十ms間に断続的にON/OFFが出る）が発生します。

現在の設計では、IO_Task が10ms刻みに動くため、チャタリング期間中に複数回エッジが検出される可能性があります。改善策としては、「前回のエッジ検出から○ms以上経過するまで次のエッジは無視する」という**マスク時間**を追加することです。

```cpp
// 改善例: マスク時間の追加
#define BTN_MASK_MS 100   // 100ms以内の再検出は無視

unsigned long T_BtnA_LastDetect = 0;  // 追加

// IO_Task 内で:
if (btnNow && !G.M_BtnA_Prev) {
  if (now - T_BtnA_LastDetect >= BTN_MASK_MS) {  // マスク時間チェック
    G.M_BtnA_Pressed = true;
    T_BtnA_LastDetect = now;
  }
}
```

### 「温度表示が激しく揺れる」

```cpp
// 確認箇所: フィルタ係数
G.D_FilteredPV = (G.D_FilteredPV * 0.9) + (G.D_RawPV * 0.1);
```

フィルタの「強さ」が不足しています。0.9を0.95に変えて、ノイズ除去を強化してください。それで改善しない場合は、センサ側の問題（熱電対の接続が不十全で電気的ノイズが混んでいる）の可能性があるため、配線を確認してください。

### 「平均値が異常に高い」

確認箇所は2つあります。

**①積算の開始タイミング。** IDLE→RUNの遷移で Sum と Count がゼロリセットされているか確認してください。

```cpp
case STATE_IDLE:
  G.D_Sum   = 0.0;   // ← ここが抜けていたら前回の積算が残る
  G.D_Count = 0;
  G.M_CurrentState = STATE_RUN;
  break;
```

**②温度自体がおかしい。** IDLE状態の瞬時値と、RESULT状態の平均値の差が大きい場合、計測中に温度が実際に上昇していたのかもしれません。「計測開始直後の過渡状態の値が平均に混んでいる」という問題です。この場合は、測定開始後に数秒待ってからBtnAを押す手順を徹底することで改善できます。

---

## 5. Phase 2 機能を追加する場合の設計指針

「SDカード保存」を例に、この3層構成にどう書き足すかを説明します。

```
現在の構成

IO_Task    → センサ読込・フィルタ・ボタン読込
Logic_Task → 状態遷移・積算
UI_Task    → LCD表示
```

SDカード保存には以下の3つの要素があります。「計測データを記録する」「書き込みタイミングを管理する」「書き込みエラーを表示する」。これらをそれぞれ適切なタスクに割り当てると以下になります。

```
追加後の構成

IO_Task    → センサ読込・フィルタ・ボタン読込
             + SDカードへの書き込み実行    ← ここに追加
Logic_Task → 状態遷移・積算
             + 書き込みバッファの管理      ← ここに追加
UI_Task    → LCD表示
             + SD書き込みエラー表示        ← ここに追加
```

**IO_Task に書き込み実行を入れる理由：** SDカードへの書き込みは「外部デバイスとの通信」なので、IO層の責任です。Logic_Task や UI_Task の中で書き込みを直接行うと、その書き込みにかかる時間で他のタスクが遅延するリスクが出ます。

**Logic_Task にバッファ管理を入れる理由：** 「今書き込むべき値があるか」「書き込みは何サンプルごとにするか」といった判定は、演算・制御の意思決定なのでLogicの責任です。

**UI_Task にエラー表示を入れる理由：** エラーの検出は IO_Task で行い、フラグを立てるだけです。「そのフラグを画面に反映する」という部分は表示の責任なので UI_Task で処理します。

この原則は「**各タスクの責任域を超えて処理を書かない**」という設計の基本です。この構成を維持すると、機能が増えても各タスクの役割が混乱しにくい。
